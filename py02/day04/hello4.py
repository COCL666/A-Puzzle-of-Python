#!/usr/local/bin/python3

# 复杂列表的排序
# 列表的sort方法,接受一个名为key的参数
# key需要是一个函数
# key函数处理列表的每一项,将处理结果作为排序依据。
# key函数不改变列表
#
# >>> result = {'172.40.58.150': 10, '172.40.58.124': 6, '172.40.58.101': 10, '127.0.0.1': 121, '192.168.4.254': 103, '192.168.2.254': 110, '201.1.1.254': 173, '201.1.2.254': 119, '172.40.0.54': 391, '172.40.50.116': 244}
# >>> list(result.items())
# [('172.40.58.150', 10), ('172.40.58.124', 6), ('172.40.58.101', 10), ('127.0.0.1', 121), ('192.168.4.254', 103), ('192.168.2.254', 110), ('201.1.1.254', 173), ('201.1.2.254', 119), ('172.40.0.54', 391), ('172.40.50.116', 244)]
# >>> l = list(result.items())
# >>> def get_last(seq):   # 接受一个序列对象
# ...   return seq[-1]     # 返回序列中的最后一项
# ...
# >>> l.sort(key=get_last)
# >>> l
# [('172.40.58.124', 6), ('172.40.58.150', 10), ('172.40.58.101', 10), ('192.168.4.254', 103), ('192.168.2.254', 110), ('201.1.2.254', 119), ('127.0.0.1', 121), ('201.1.1.254', 173), ('172.40.50.116', 244), ('172.40.0.54', 391)]

# 倒序排列
# >>> l.sort(key=lambda seq:seq[-1],reverse=True)
# >>> l
# [('172.40.0.54', 391), ('172.40.50.116', 244), ('201.1.1.254', 173), ('127.0.0.1', 121), ('201.1.2.254', 119), ('192.168.2.254', 110), ('192.168.4.254', 103), ('172.40.58.150', 10), ('172.40.58.101', 10), ('172.40.58.124', 6)]

# Mysql:增删改查
# PyMySQL模块
# PyMySQL安装
# https://pypi.org

# 安装pip工具
# 下载pip-20.0.2-->解压-->cd pip.20.0.2-->python3 setup.py install
# python3 setup.py install如果写的是python,会将模块安装到python2中

# 在线安装
# pip工具类似于yum,yum安装rpm包,pip安装python包
# [root@zl2 ~]# mkdir ~/.pip
# [root@zl2 ~]# vim ~/.pip/pip.conf
# [global]
# index-url = http://mirrors.aliyun.com/pypi/simple/
# [install]
# trusted-host=mirrors.aliyun.com
# [root@zl2 ~]# pip3 install pymysql

# 环境准备
# yum install -y mariadb mariadb-server mariadb-devel

# 准备数据库
# 你正在为一个小公司编写程序,需要记录员工的基本信息和发工资的情况
# 需要记录的字段:姓名,性别,出生日期,联系方式,部门,员工,工作日,基本工资,奖金,工资总额
# 在建表时,要注意尽量避免数据冗余,(如:人事,人事部,人力资源),为了减少冗余,可以将字段放到不同的表中.

# 员工表:姓名,性别,出生日期,联系方式,部门ID
# 部门表:部门ID,部门名称
# 工资表:姓名,工资日,基本工资,奖金,工资总额

# 数据库六范式
# 1.第一范式 1NF
# 定义:属于第一范式关系的所有属性都不可再分,即数据项不可分.
# 理解:第一范式强调数据表的原子性,是其他范式的基础.
# 2.第二范式 2NF
# 定义:若某关系R属于第一范式,且每一个非主属性完全函数依赖于任何一个候选码,则关系R属于第二范式.
# 此处我们需要理解非主属性,候选码和完全函数依赖的概念.
# 即,每张表都需要一个主键
# 员工表:员工编号
# 部门表:部门id
# 工资表:额外加字段id
# 3. 第三范式 3NF
# 定义:非主属性既不传递依赖于码,也不部分依赖于码.
# 工资总额是通过基本工资和奖金计算出来的

# 根据数据库范式，最终得到的3张表是：
# 员工表：员工ID、姓名、email、部门ID
# 部门表：部门ID、部门名称
# 工资表：id、员工ID、工资日、基本工资、奖金

# SQLAlChemy
# 可以连接各种各样的关系型数据库
# 不需要写SQL语句
#
# ORM
# Object：对象
# Relationship：关系
# Mapper：映射
# 数据库中的每张表都映射成一个class
# 表中的字段映射成为class的类变量
# 表的记录映射为class的实例
# 字段的数据类型，映射为sqlalchemy的类

